<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lucene.Net.Search.SparseFacetedSearch</name>
    </assembly>
    <members>
        <member name="T:Lucene.Net.Search.FieldValuesDocIDs">
            <summary>
            "internal" class to extract the DocIDs of each value of a field
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FacetCount">
            <summary>
            Simplified version of FacetHits containing the count only.
            <para>
            This means that IndexReader does not need to be held open.
            Useful for the majority of casses where we're only interested in the count and not the individual Documents.
            </para>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.SparseFacetedSearcher">
            <summary>
            Based on SimpleFacetedSearch. Uses DocID lists instead on bitmaps.
            Efficient memory usage for high cardinality sparsely populated facets.
            <para>
            Suitable for high cardinality, sparsely populated facets.
            i.e. There are a large number of facet values and each facet value is hit in a small percentage of documents. Especially if there are also a large number of documents.
            SimpleFacetedSearch holds a bitmap for each value representing whether that value is a hit is each document (approx 122KB per 1M documents per facet value).
            So this is an O(N*M) problem. The memory requirement can grow very quickly.
            </para>
            <para>
            SparseFacetedSearcher records the DocID (Int32) for each value hit (memory cost = values * hits * 4).
            SimpleFacetedSearch record a bit for evey document per value (memory cost = values * documents / 8).
            So if the average number of hits for each value is less than 1/32 or 3.125% then Sparse is more memory efficient.
            <para>
            There are also some enumerable methods than mean there is much less pressure on the GC.
            Plus some bug fixes.
            </para>
            </para>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FacetCountResult">
            <summary>
            The result from SparseFacetedSearcher.Count.
            Represents the collection of count per facet
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FacetSearchResult">
            <summary>
            The result from SparseFacetedSearcher.Search.
            Represents the collection of count and Documents per facet
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FacetHits">
            <summary>
            Represents the Documents containing a facet value
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Extensions.Concat``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Version of Enumerable.Concat but adding only a single additional item.
            <para>
            This avoid the creation of a new array in the CartesianProduct functions
            </para>
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="first"></param>
            <param name="additionalItem"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Search.Extensions.AsEnumerable(Lucene.Net.Search.DocIdSet)">
            <summary>
            Presents an Ienumerable version of the DocIdSet Iterator
            </summary>
            <param name="set"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Search.Extensions.WalkingIntersect(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Assuming <paramref name="source"/> and <paramref name="other"/> are ordered. Returns another IEnumerable containing the common values.
            </summary>
            <param name="source">Ordered sequence of int</param>
            <param name="other">Ordered sequence of int</param>
            <returns>Returns another IEnumerable containing the common values</returns>
        </member>
    </members>
</doc>
